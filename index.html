<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr TODO List</title>
    <script src="https://unpkg.com/nostr-tools/lib/nostr.bundle.js"></script>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 800px;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        h1 {
            margin: 0;
        }
        #add-todo-btn {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
        }
        #add-todo-btn:hover {
            background-color: #0056b3;
        }
        #todo-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }
        .todo-card {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .todo-card .content {
            margin-bottom: 10px;
            word-wrap: break-word; /* Ensure long content wraps */
        }
        .todo-card .meta {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 10px;
        }
        .todo-card .meta span {
            display: block;
            margin-bottom: 5px;
        }
        .todo-card .actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        .todo-card .actions button {
            padding: 5px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .todo-card .actions .update-btn {
            background-color: #ffc107;
            color: #333;
        }
        .todo-card .actions .update-btn:hover {
            background-color: #e0a800;
        }
         .todo-card .actions .zap-btn {
            background-color: #9c27b0;
            color: white;
        }
        .todo-card .actions .zap-btn:hover {
            background-color: #7b1fa2;
        }
        .todo-card .actions .zap-info {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .todo-card .actions .zap-amount {
            font-weight: bold;
            color: #9c27b0;
        }

        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgb(0,0,0); /* Fallback color */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto; /* 15% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%; /* Could be more or less, depending on screen size */
            max-width: 500px;
            border-radius: 8px;
            position: relative;
        }
        .close-btn {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
        }
        .close-btn:hover,
        .close-btn:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        #todo-text {
            width: calc(100% - 22px); /* Account for padding/border */
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #submit-todo-btn {
            padding: 10px 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #submit-todo-btn:hover {
            background-color: #218838;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            #todo-list {
                grid-template-columns: 1fr; /* Stack cards on small screens */
            }
            .modal-content {
                width: 90%;
                margin: 20% auto;
            }
        }

        /* Toast Notification Styles */
        #toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .toast {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 0.9em;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .toast.show {
            opacity: 1;
        }
         .toast.error { /* Optional style for errors */
            background-color: rgba(217, 83, 79, 0.8); /* Bootstrap danger color */
        }

        /* Filter Styles */
        .filters {
            margin-bottom: 20px;
            padding: 10px;
            background-color: #eee;
            border-radius: 5px;
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 20px; /* Spacing between filter groups */
            align-items: center;
        }
        .filter-group {
            display: flex;
            gap: 10px; /* Spacing within a group */
            align-items: center;
        }
         .filter-group label {
            margin-right: 5px; /* Space between input and label text */
            cursor: pointer;
        }
         .filter-group input[type="radio"],
         .filter-group input[type="checkbox"] {
             cursor: pointer;
         }
         .filter-group strong { /* Style the group titles */
             font-weight: bold;
             margin-right: 5px;
         }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Nostr TODOs</h1>
            <button id="add-todo-btn">Add TODO</button>
        </header>

        <!-- Filter Controls -->
        <div class="filters">
            <div class="filter-group">
                <strong>Show:</strong>
                <input type="radio" id="filter-global" name="scope" value="global" checked>
                <label for="filter-global">Global</label>
                <input type="radio" id="filter-own" name="scope" value="own">
                <label for="filter-own">Own</label>
            </div>
            <div class="filter-group">
                <strong>Status:</strong>
                <input type="checkbox" id="filter-todo" value="TODO" checked>
                <label for="filter-todo">TODO</label>
                <input type="checkbox" id="filter-doing" value="DOING" checked>
                <label for="filter-doing">Doing</label>
                <input type="checkbox" id="filter-done" value="DONE">
                <label for="filter-done">Done</label>
            </div>
        </div>

        <div id="todo-list">
            <!-- TODO cards will be inserted here -->
            <p>Loading TODOs...</p>
        </div>
    </div>

    <!-- Add TODO Modal -->
    <div id="add-todo-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <h2>Add New TODO</h2>
            <textarea id="todo-text" rows="4" placeholder="What needs to be done?"></textarea>
            <button id="submit-todo-btn">Submit TODO</button>
        </div>
    </div>

    <!-- Update TODO Modal -->
    <div id="update-todo-modal" class="modal">
        <div class="modal-content">
            <span class="close-update-btn close-btn">&times;</span>
            <h2>Update TODO Status</h2>
            <input type="hidden" id="update-event-id"> <!-- To store the event ID -->
            <div id="status-options" style="margin-bottom: 15px; display: flex; flex-direction: column; gap: 10px;">
                 <label>
                    <input type="radio" name="update-status" value="TODO" id="update-status-todo">
                    üìù TODO
                </label>
                <label>
                    <input type="radio" name="update-status" value="DOING" id="update-status-doing">
                    ‚è≥ DOING
                </label>
                <label>
                    <input type="radio" name="update-status" value="DONE" id="update-status-done">
                    ‚úÖ DONE
                </label>
            </div>
            <button id="submit-update-btn">Submit Update</button>
        </div>
    </div>


    <script>
        const { SimplePool, finalizeEvent, nip19 } = NostrTools;

        const pool = new SimplePool();
        const relays = ['wss://relay.damus.io', 'wss://nos.lol'];
        const todoListElement = document.getElementById('todo-list');
        const addTodoBtn = document.getElementById('add-todo-btn');
        const addModal = document.getElementById('add-todo-modal');
        const closeAddModalBtn = addModal.querySelector('.close-btn');
        const submitTodoBtn = document.getElementById('submit-todo-btn');
        const todoTextArea = document.getElementById('todo-text');

        // Update Modal Elements
        const updateModal = document.getElementById('update-todo-modal');
        const closeUpdateModalBtn = updateModal.querySelector('.close-update-btn');
        const submitUpdateBtn = document.getElementById('submit-update-btn');
        const updateEventIdInput = document.getElementById('update-event-id');
        const updateStatusOptions = updateModal.querySelectorAll('input[name="update-status"]');

        // --- Data Store ---
        // Store TODOs, keyed by event id
        // value: { event: NostrEvent, name: string, status: string, zapTotal: number, subs: { profile: Sub, status: Sub, zaps: Sub } }
        const todos = new Map();
        let currentUserPubkey = null;
        let currentScope = 'global'; // 'global' or 'own'
        let currentStatuses = new Set(['TODO', 'DOING']); // Default statuses

        // --- Utility Functions ---
        function shortenNpub(npub) {
            if (!npub || npub.length < 16) return npub;
            return `${npub.substring(0, 8)}...${npub.substring(npub.length - 8)}`;
        }

        function formatSats(msats) {
            return Math.floor(msats / 1000);
        }

        // --- Toast Notification ---
        const toastContainer = document.createElement('div');
        toastContainer.id = 'toast-container';
        document.body.appendChild(toastContainer);

        function showToast(message, duration = 3000, isError = false) {
            const toast = document.createElement('div');
            toast.classList.add('toast');
            if (isError) {
                toast.classList.add('error');
            }
            toast.textContent = message;
            toastContainer.appendChild(toast);

            // Force reflow to enable transition
            toast.offsetHeight;

            // Show toast
            toast.classList.add('show');

            // Hide and remove toast after duration
            setTimeout(() => {
                toast.classList.remove('show');
                // Remove the element after the transition completes
                setTimeout(() => {
                    if (toast.parentNode === toastContainer) {
                         toastContainer.removeChild(toast);
                    }
                }, 500); // Match transition duration
            }, duration);
        }

        // --- Rendering ---
        function renderTodoCard(todoData) {
            const { event, name, status, zapTotal } = todoData;
            const cardId = `todo-${event.id}`;
            let card = document.getElementById(cardId);

            if (!card) {
                card = document.createElement('div');
                card.classList.add('todo-card');
                card.id = cardId;
                card.dataset.eventId = event.id; // Store event id for actions
                card.dataset.authorPubkey = event.pubkey; // Store author pubkey for actions
            }

            const authorNpub = nip19.npubEncode(event.pubkey);
            const displayName = name || shortenNpub(authorNpub);

            // Conditionally add the update button HTML
            const isOwner = currentUserPubkey && currentUserPubkey === event.pubkey;
            const updateButtonHTML = isOwner ? `<button class="update-btn">Update</button>` : '';

            card.innerHTML = `
                <div class="content">${event.content}</div>
                <div class="meta">
                    <span class="author">By: ${displayName}</span>
                    <span class="status">Status: ${status}</span>
                </div>
                <div class="actions">
                    <div class="zap-info">
                         <button class="zap-btn" title="Zap this TODO">‚ö° Zap</button>
                         <span class="zap-amount">${formatSats(zapTotal)} sats</span>
                    </div>
                    ${updateButtonHTML}
                </div>
            `;

            // Add event listeners for buttons within this card
            // Conditionally attach listener only if the button exists
            const updateButton = card.querySelector('.update-btn');
            if (updateButton) {
                updateButton.addEventListener('click', handleUpdateClick);
            }
            card.querySelector('.zap-btn').addEventListener('click', handleZapClick);

            return card;
        }

        function renderTodoList() {
            // 1. Filter Todos based on current state
            const filteredTodos = Array.from(todos.values()).filter(todoData => {
                // Scope filter
                const scopeMatch = currentScope === 'global' || (currentScope === 'own' && currentUserPubkey && todoData.event.pubkey === currentUserPubkey);
                if (!scopeMatch) return false;

                // Status filter
                const statusMatch = currentStatuses.has(todoData.status.toUpperCase());
                if (!statusMatch) return false;

                return true; // Passes both filters
            });

            // 2. Clear current list or show appropriate message
            todoListElement.innerHTML = ''; // Clear previous content
            if (filteredTodos.length === 0) {
                 let message = "No TODOs match the current filters.";
                 if (todos.size === 0) {
                     message = "No TODOs found yet. Add one!";
                 } else if (currentScope === 'own' && !currentUserPubkey) {
                     message = "Connect your Nostr extension to see your own TODOs.";
                 }
                 todoListElement.innerHTML = `<p>${message}</p>`;
                 return;
            }


            // 3. Sort filtered todos by zapTotal descending
            const sortedTodos = filteredTodos.sort((a, b) => b.zapTotal - a.zapTotal);

            // 4. Efficiently update DOM with filtered & sorted todos
            const fragment = document.createDocumentFragment();
            sortedTodos.forEach(todoData => {
                fragment.appendChild(renderTodoCard(todoData));
            });
            todoListElement.appendChild(fragment);
        }


        // --- Nostr Logic ---

        async function checkNostrExtension() {
            if (window.nostr) {
                try {
                    currentUserPubkey = await window.nostr.getPublicKey();
                    console.log(`Nostr extension found. Pubkey: ${currentUserPubkey}`);
                    return true;
                } catch (error) {
                    console.error("Error getting public key from Nostr extension:", error);
                    showToast("Could not get public key from Nostr extension. Please ensure it's set up correctly.", 5000, true);
                    return false;
                }
            } else {
                showToast("Nostr extension not found. Please install one (e.g., Alby) and reload.", 5000, true);
                // Disable buttons that require the extension
                addTodoBtn.disabled = true;
                submitTodoBtn.disabled = true;
                // We might want to disable update buttons too, but they are added dynamically
                return false;
            }
        }

        function subscribeToProfile(pubkey, todoId) {
            if (!todos.has(todoId) || todos.get(todoId).subs.profile) return; // Already subscribed or TODO removed

            const sub = pool.subscribeMany(
                relays,
                [{ kinds: [0], authors: [pubkey], limit: 1 }],
                {
                    onevent(event) {
                        try {
                            const profile = JSON.parse(event.content);
                            const name = profile.name || profile.display_name || profile.displayName;
                            if (name && todos.has(todoId)) {
                                todos.get(todoId).name = name;
                                renderTodoList(); // Re-render to show name
                            }
                        } catch (e) {
                            console.error(`Failed to parse profile metadata for ${pubkey}:`, e);
                        }
                    },
                    oneose() {
                        // console.log(`Profile subscription closed for ${pubkey}`);
                        // Don't close subscription based on EOSE as profiles can update
                    }
                }
            );
            if (todos.has(todoId)) {
                todos.get(todoId).subs.profile = sub;
            }
        }

        function subscribeToStatus(eventId, authorPubkey, todoId) {
             if (!todos.has(todoId) || todos.get(todoId).subs.status) return; // Already subscribed or TODO removed

            let latestStatus = null;
            let latestTimestamp = 0;

            const sub = pool.subscribeMany(
                relays,
                [{ kinds: [714], authors: [authorPubkey], "#e": [eventId] }],
                {
                    onevent(event) {
                        if (event.created_at > latestTimestamp) {
                            latestTimestamp = event.created_at;
                            latestStatus = event.content;
                            if (todos.has(todoId)) {
                                todos.get(todoId).status = latestStatus;
                                renderTodoList(); // Re-render to show new status
                            }
                        }
                    },
                    oneose() {
                        // console.log(`Status subscription EOSE for ${eventId}`);
                        // Keep listening for new status updates
                    }
                }
            );
             if (todos.has(todoId)) {
                todos.get(todoId).subs.status = sub;
            }
        }

         function subscribeToZaps(eventId, todoId) {
             if (!todos.has(todoId) || todos.get(todoId).subs.zaps) return; // Already subscribed or TODO removed

            const sub = pool.subscribeMany(
                relays,
                [{ kinds: [9735], "#e": [eventId] }],
                {
                    onevent(event) {
                        try {
                            const descriptionTag = event.tags.find(tag => tag[0] === 'description');
                            if (descriptionTag && descriptionTag[1]) {
                                const zapRequest = JSON.parse(descriptionTag[1]);
                                const amountTag = zapRequest.tags.find(tag => tag[0] === 'amount');
                                if (amountTag && amountTag[1]) {
                                    const msats = parseInt(amountTag[1], 10);
                                    if (!isNaN(msats) && todos.has(todoId)) {
                                        // Note: This adds amount for *every* zap receipt event.
                                        // If relays send duplicates, this could inflate totals.
                                        // A more robust solution might track zap receipt IDs.
                                        // For simplicity here, we assume mostly unique receipts arrive.
                                        // Let's reset and recalculate on each new zap for simplicity now.
                                        // TODO: Improve zap calculation robustness if needed.

                                        // Simple recalculation approach:
                                        let currentTotal = todos.get(todoId).zapTotal || 0;
                                        // Let's just add for now, assuming events are unique enough for demo
                                        todos.get(todoId).zapTotal = currentTotal + msats;
                                        renderTodoList(); // Re-render and sort
                                    }
                                }
                            }
                        } catch (e) {
                            console.error(`Failed to parse zap receipt or request for ${eventId}:`, e);
                        }
                    },
                    oneose() {
                        // console.log(`Zap subscription EOSE for ${eventId}`);
                        // Keep listening for new zaps
                    }
                }
            );
             if (todos.has(todoId)) {
                todos.get(todoId).subs.zaps = sub;
            }
        }

        function subscribeToTodos() {
            console.log("Subscribing to TODO events (kind 713)...");
            const sub = pool.subscribeMany(
                relays,
                [{ kinds: [713] }], // Add limit later if needed for performance
                {
                    onevent(event) {
                        // console.log("Received TODO event:", event);
                        if (!todos.has(event.id)) {
                            todos.set(event.id, {
                                event: event,
                                name: null, // Fetched via kind 0
                                status: "TODO", // Default, updated via kind 714
                                zapTotal: 0, // Calculated via kind 9735
                                subs: { profile: null, status: null, zaps: null }
                            });
                            // Trigger subscriptions for details
                            subscribeToProfile(event.pubkey, event.id);
                            subscribeToStatus(event.id, event.pubkey, event.id);
                            subscribeToZaps(event.id, event.id);
                            renderTodoList(); // Initial render
                        } else {
                            // Potentially update event if replaceable logic applied later, but kind 713 is regular
                            // console.log("Duplicate TODO event received:", event.id);
                        }
                    },
                    oneose() {
                        console.log("Initial TODO sync complete (EOSE received). Listening for new TODOs...");
                        if (todos.size === 0) {
                             todoListElement.innerHTML = '<p>No TODOs found yet. Add one!</p>';
                        }
                    }
                }
            );
            // We don't close this subscription
        }

        // --- Event Handlers ---
        addTodoBtn.onclick = () => {
            if (!currentUserPubkey) {
                checkNostrExtension(); // Re-check or show alert
                return;
            }
            todoTextArea.value = ''; // Clear previous input
            addModal.style.display = "block";
        };

        closeAddModalBtn.onclick = () => {
            addModal.style.display = "none";
        };

        window.onclick = (event) => {
            if (event.target == addModal) {
                addModal.style.display = "none";
            } else if (event.target == updateModal) {
                updateModal.style.display = "none";
            }
        };

        submitTodoBtn.onclick = async () => {
            const content = todoTextArea.value.trim();
            if (!content) {
                alert("Please enter some text for the TODO.");
                return;
            }
            if (!window.nostr) {
                alert("Nostr extension not available.");
                return;
            }

            const eventTemplate = {
                kind: 713,
                created_at: Math.floor(Date.now() / 1000),
                tags: [],
                content: content,
            };

            try {
                console.log("Signing event:", eventTemplate);
                const signedEvent = await window.nostr.signEvent(eventTemplate);
                console.log("Publishing event:", signedEvent);

                // pool.publish returns a Promise that resolves when the event is sent
                // It doesn't have .on() handlers like subscribe
                await pool.publish(relays, signedEvent);
                console.log(`Event ${signedEvent.id} published attempt initiated.`);

                // Provide feedback after successful publish attempt
                showToast("TODO submitted!");

                addModal.style.display = "none";
                // The main subscription will pick up the event and render it
            } catch (error) {
                console.error("Error signing or publishing TODO:", error);
                showToast(`Failed to submit TODO: ${error.message || error}`, 5000, true);
            }
        };

        async function handleUpdateClick(clickEvent) {
            const card = clickEvent.target.closest('.todo-card');
            const eventId = card.dataset.eventId;
            const authorPubkey = card.dataset.authorPubkey;

            if (!window.nostr) {
                showToast("Nostr extension not available.", 5000, true);
                return;
            }
            if (!currentUserPubkey) {
                 // Attempt to get it again if null
                 const hasExtension = await checkNostrExtension();
                 if (!hasExtension || !currentUserPubkey) return;
            }


            if (currentUserPubkey !== authorPubkey) {
                showToast("You are not the owner of this TODO.", 5000, true);
                return;
            }

            // --- Show Update Modal ---
            const currentTodoData = todos.get(eventId);
            if (!currentTodoData) {
                showToast("Could not find TODO data.", 5000, true);
                return;
            }
            const currentStatus = currentTodoData.status.toUpperCase();

            // Set hidden input value
            updateEventIdInput.value = eventId;

            // Check the correct radio button
            updateStatusOptions.forEach(radio => {
                radio.checked = (radio.value === currentStatus);
            });

            // Display the modal
            updateModal.style.display = "block";
        }

        // --- Update Modal Submit Handler ---
        submitUpdateBtn.onclick = async () => {
            const eventId = updateEventIdInput.value;
            let newStatus = null;
            updateStatusOptions.forEach(radio => {
                if (radio.checked) {
                    newStatus = radio.value;
                }
            });

            if (!eventId || !newStatus) {
                showToast("Could not get event ID or selected status.", 5000, true);
                return;
            }
            if (!window.nostr) {
                showToast("Nostr extension not available.", 5000, true);
                return;
            }
            // No need to re-check owner here as it was done in handleUpdateClick

            // Proceed with publishing the update event

            const eventTemplate = {
                kind: 714,
                created_at: Math.floor(Date.now() / 1000),
                tags: [["e", eventId]],
                content: newStatus.toUpperCase(),
            };

            try {
                console.log("Signing status update:", eventTemplate);
                const signedEvent = await window.nostr.signEvent(eventTemplate);
                console.log("Publishing status update:", signedEvent);

                // pool.publish returns a Promise that resolves when the event is sent
                await pool.publish(relays, signedEvent);
                console.log(`Status update ${signedEvent.id} published attempt initiated.`);

                // Provide feedback after successful publish attempt
                showToast("Status updated!");

                // The status subscription will pick up the change and re-render
            } catch (error) {
                console.error("Error signing or publishing status update:", error);
                showToast(`Failed to update status: ${error.message || error}`, 5000, true);
            } finally {
                // Hide the modal regardless of success/failure
                updateModal.style.display = "none";
            }
        };

        // --- Update Modal Close Handler ---
        closeUpdateModalBtn.onclick = () => {
            updateModal.style.display = "none";
        };

        // --- Zap Logic Helpers ---

        // Parses lud06 (lnurl1...) or lud16 (user@domain) to get LNURL pay URL
        // Requires nip19 from nostr-tools
        function parseLnUrl(lnurl) {
            try {
                if (!lnurl) return null;
                if (lnurl.toLowerCase().startsWith('lnurl1')) {
                    const decoded = nip19.decode(lnurl);
                    if (decoded.type === 'lnurl') {
                        return decoded.data;
                    }
                } else if (lnurl.includes('@')) {
                    const [name, domain] = lnurl.split('@');
                    if (name && domain) {
                        return `https://${domain}/.well-known/lnurlp/${name}`;
                    }
                }
            } catch (e) {
                console.error("Error parsing LNURL/address:", e);
            }
            return null;
        }

        // Fetches user profile and extracts LNURL pay URL
        async function fetchProfileAndLNURL(pubkey) {
            try {
                console.log(`Fetching profile for ${pubkey}...`);
                const profileEvent = await pool.get(relays, { kinds: [0], authors: [pubkey], limit: 1 });
                if (!profileEvent) {
                    console.log(`No profile found for ${pubkey}`);
                    return null;
                }
                console.log(`Found profile event for ${pubkey}:`, profileEvent);
                const profileData = JSON.parse(profileEvent.content);
                const lnurl = profileData.lud06 || profileData.lud16; // Prefer lud06 if both exist

                if (!lnurl) {
                    console.log(`No lud06 or lud16 found in profile for ${pubkey}`);
                    return null;
                }

                const lnurlPayUrl = parseLnUrl(lnurl);
                if (!lnurlPayUrl) {
                     console.log(`Could not parse LNURL/address: ${lnurl}`);
                     return null;
                }

                console.log(`Found LNURL pay URL for ${pubkey}: ${lnurlPayUrl}`);
                return { lnurlPayUrl, originalLnUrl: lnurl }; // Return original for zap request tag

            } catch (error) {
                console.error(`Error fetching or parsing profile for ${pubkey}:`, error);
                return null;
            }
        }


        // --- Zap Click Handler ---
        async function handleZapClick(clickEvent) {
            const card = clickEvent.target.closest('.todo-card');
            const eventId = card.dataset.eventId;
            const recipientPubkey = card.dataset.authorPubkey;

            // 1. Check for necessary extensions
            // 1. Check for necessary extensions
            if (!window.nostr) {
                showToast("Nostr extension not found or not enabled. Needed to sign zap request.", 5000, true);
                return;
            }
             if (!window.webln) {
                showToast("WebLN provider not found or not enabled. Needed to pay the invoice.", 5000, true);
                return;
            }
            if (!currentUserPubkey) {
                 const hasExtension = await checkNostrExtension(); // Ensure we have sender pubkey
                 if (!hasExtension || !currentUserPubkey) return;
            }

            // 2. Get Zap Amount
            const satsInput = prompt("Enter amount in sats to zap:", "21");
            if (satsInput === null) return; // User cancelled
            const sats = parseInt(satsInput, 10);
            if (isNaN(sats) || sats <= 0) {
                showToast("Invalid amount.", 5000, true);
                return;
            }
            const amountMsats = sats * 1000;

            try {
                 // Enable webln
                 await window.webln.enable();

                // 3. Get Recipient LNURL Pay URL
                const lnurlData = await fetchProfileAndLNURL(recipientPubkey);
                if (!lnurlData || !lnurlData.lnurlPayUrl) {
                    showToast("Could not find a valid Lightning Address or LNURL for the recipient.", 5000, true);
                    return;
                }
                const { lnurlPayUrl, originalLnUrl } = lnurlData;

                // 4. LNURL-Pay: Step 1 - Fetch LNURL params
                console.log(`Fetching LNURL params from: ${lnurlPayUrl}`);
                const lnurlResponse = await fetch(lnurlPayUrl);
                if (!lnurlResponse.ok) {
                    throw new Error(`LNURL request failed: ${lnurlResponse.statusText}`);
                }
                const lnurlParams = await lnurlResponse.json();
                console.log("LNURL params:", lnurlParams);

                if (lnurlParams.status === 'ERROR') {
                    throw new Error(`LNURL Error: ${lnurlParams.reason || 'Unknown reason'}`);
                }
                if (!lnurlParams.callback || !lnurlParams.tag === "payRequest") {
                     throw new Error("Invalid LNURL-pay response.");
                }
                 if (!lnurlParams.allowsNostr || lnurlParams.nostrPubkey === undefined) { // Check allowsNostr explicitly
                    showToast("Recipient's wallet does not support Nostr Zaps.", 5000, true);
                    return;
                }
                 // Optional: Check amount limits
                if (amountMsats < (lnurlParams.minSendable || 0) || amountMsats > (lnurlParams.maxSendable || Infinity)) {
                    showToast(`Amount must be between ${formatSats(lnurlParams.minSendable || 0)} and ${formatSats(lnurlParams.maxSendable || Infinity)} sats.`, 5000, true);
                    return;
                }


                // 5. Create Zap Request Event (Kind 9734)
                const zapRequestEvent = {
                    kind: 9734,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [
                        ["relays", ...relays], // Include relays for zap receipt publishing
                        ["amount", amountMsats.toString()],
                        ["lnurl", originalLnUrl], // Use the original lud06/16 from profile
                        ["p", recipientPubkey],
                        ["e", eventId] // Tag the event being zapped
                    ],
                    content: `Zap for TODO: ${eventId}` // Optional content
                };

                // 6. Sign Zap Request
                console.log("Signing Zap Request:", zapRequestEvent);
                const signedZapRequest = await window.nostr.signEvent(zapRequestEvent);
                console.log("Signed Zap Request:", signedZapRequest);

                // 7. LNURL-Pay: Step 2 - Fetch Invoice via Callback
                const callbackUrl = new URL(lnurlParams.callback);
                callbackUrl.searchParams.set('amount', amountMsats.toString());
                callbackUrl.searchParams.set('nostr', JSON.stringify(signedZapRequest));
                // Add lnurl again as per spec, though some servers might not require if nostr is present
                callbackUrl.searchParams.set('lnurl', originalLnUrl);

                console.log(`Fetching invoice from callback: ${callbackUrl.toString()}`);
                const invoiceResponse = await fetch(callbackUrl.toString());
                 if (!invoiceResponse.ok) {
                    const errorText = await invoiceResponse.text();
                    throw new Error(`Callback request failed: ${invoiceResponse.statusText} - ${errorText}`);
                }
                const invoiceData = await invoiceResponse.json();
                 console.log("Invoice data:", invoiceData);

                if (invoiceData.status === 'ERROR') {
                    throw new Error(`Callback Error: ${invoiceData.reason}`);
                }
                if (!invoiceData.pr) {
                    throw new Error("No invoice (pr) received from callback.");
                }
                const invoice = invoiceData.pr;

                // 8. Pay Invoice via WebLN
                console.log("Requesting payment for invoice:", invoice);
                const paymentResult = await window.webln.sendPayment(invoice);
                console.log("Payment result:", paymentResult);

                // Preimage is proof of payment
                if (paymentResult && paymentResult.preimage) {
                     showToast(`Zap successful! ${sats} sats sent.`);
                     // The zap subscription (kind 9735) should eventually update the UI total
                } else {
                    throw new Error("Payment failed or no preimage received.");
                }

            } catch (error) {
                console.error("Zap failed:", error);
                showToast(`Zap failed: ${error.message || error}`, 5000, true);
            }
        }


        // --- Initialization ---
        async function main() {
            const hasExtension = await checkNostrExtension();
            // Proceed even if extension check fails initially, but some features will be disabled.
            // The check will happen again if user tries actions requiring it.

            console.log("Connecting to relays:", relays);
            // Ensure relays are connected before subscribing
            // SimplePool connects automatically on first sub/pub, but explicit connect is clearer
            try {
                 await Promise.all(relays.map(url => pool.ensureRelay(url).connect()));
                 console.log("Connected to relays.");
            } catch (error) {
                 console.error("Failed to connect to one or more relays:", error);
                 // Continue anyway, pool might connect later or partially work
            }


            subscribeToTodos();

            // Add Filter Event Listeners
            document.querySelectorAll('input[name="scope"]').forEach(radio => {
                radio.addEventListener('change', (event) => {
                    currentScope = event.target.value;
                    // Disable "Own" if pubkey not available
                    if (currentScope === 'own' && !currentUserPubkey) {
                        showToast("Connect Nostr extension to filter by 'Own'.", 3000, true);
                        event.target.checked = false; // Revert selection
                        document.getElementById('filter-global').checked = true; // Select global again
                        currentScope = 'global';
                    }
                    renderTodoList();
                });
            });

            document.querySelectorAll('.filters input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', (event) => {
                    if (event.target.checked) {
                        currentStatuses.add(event.target.value);
                    } else {
                        currentStatuses.delete(event.target.value);
                    }
                    renderTodoList();
                });
            });
        }

        main();

    </script>
    <!-- Toast container is added dynamically by JS -->
</body>
</html>